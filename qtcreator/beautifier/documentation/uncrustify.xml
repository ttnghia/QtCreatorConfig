<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!--Created 2015-06-02T16:19:59-->
<beautifier_documentation>
    <entry>
        <key>newlines</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;newlines&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Auto, LF, CR, CRLF }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The type of line endings&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>input_tab_size</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;input_tab_size&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The original size of tabs in the input&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>output_tab_size</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;output_tab_size&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The size of tabs in the output (only used if align_with_tabs=true)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>string_escape_char</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;string_escape_char&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The ASCII value of the string escape char, usually 92 (\) or 94 (^). (Pawn)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>string_escape_char2</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;string_escape_char2&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Alternate string escape char for Pawn. Only works right before the quote char.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>tok_split_gte</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;tok_split_gte&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Allow interpreting '&amp;gt;=' and '&amp;gt;&amp;gt;=' as part of a template in 'void f(list&amp;lt;list&amp;lt;B&amp;gt;&amp;gt;=val);'.   If true (default), 'assert(x&amp;lt;0 &amp;amp;&amp;amp; y&amp;gt;=3)' will be broken.   Improvements to template detection may make this option obsolete.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>utf8_bom</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;utf8_bom&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control what to do with the UTF-8 BOM (recommend 'remove')&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>utf8_byte</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;utf8_byte&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If the file contains bytes with values between 128 and 255, but is not UTF-8, then output as UTF-8&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>utf8_force</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;utf8_force&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Force the output encoding to UTF-8&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_columns</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_columns&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of columns to indent per level.   Usually 2, 3, 4, or 8.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_continue</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_continue&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The continuation indent. If non-zero, this overrides the indent of '(' and '=' continuation indents.   For FreeBSD, this is set to 4. Negative value is absolute and not increased for each ( level&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_with_tabs</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_with_tabs&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  How to use tabs when indenting code   0=spaces only   1=indent with tabs to brace level, align with spaces   2=indent and align with tabs, using spaces when not on a tabstop&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_cmt_with_tabs</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_cmt_with_tabs&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Comments that are not a brace level are indented with tabs on a tabstop.   Requires indent_with_tabs=2. If false, will use spaces.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_align_string</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_align_string&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to indent strings broken by '\' so that they line up&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_xml_string</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_xml_string&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of spaces to indent multi-line XML strings.   Requires indent_align_string=True&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Spaces to indent '{' from level&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_braces</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_braces&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether braces are indented to the body level&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_braces_no_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_braces_no_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Disabled indenting function braces if indent_braces is true&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_braces_no_class</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_braces_no_class&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Disabled indenting class braces if indent_braces is true&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_braces_no_struct</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_braces_no_struct&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Disabled indenting struct braces if indent_braces is true&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_brace_parent</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_brace_parent&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Indent based on the size of the brace parent, i.e. 'if' =&amp;gt; 3 spaces, 'for' =&amp;gt; 4 spaces, etc.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_paren_open_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_paren_open_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Indent based on the paren open instead of the brace open in '({\n', default is to indent by brace.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_namespace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_namespace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether the 'namespace' body is indented&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_namespace_single_indent</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_namespace_single_indent&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Only indent one namespace and no sub-namepaces.   Requires indent_namespace=true.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_namespace_level</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_namespace_level&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of spaces to indent a namespace block&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_namespace_limit</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_namespace_limit&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If the body of the namespace is longer than this number, it won't be indented.   Requires indent_namespace=true. Default=0 (no limit)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_extern</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_extern&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether the 'extern &amp;quot;C&amp;quot;' body is indented&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_class</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_class&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether the 'class' body is indented&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_class_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_class_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to indent the stuff after a leading base class colon&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_constr_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_constr_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to indent the stuff after a leading class initializer colon&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_ctor_init_leading</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_ctor_init_leading&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Virtual indent from the ':' for member initializers. Default is 2&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_ctor_init</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_ctor_init&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Additional indenting for constructor initializer list&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_else_if</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_else_if&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  False=treat 'else\nif' as 'else if' for indenting purposes   True=indent the 'if' one level&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_var_def_blk</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_var_def_blk&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Amount to indent variable declarations after a open brace. neg=relative, pos=absolute&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_var_def_cont</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_var_def_cont&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Indent continued variable declarations instead of aligning.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_def_force_col1</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_def_force_col1&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  True:  force indentation of function definition to start in column 1   False: use the default behavior&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_call_param</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_call_param&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  True:  indent continued function call parameters one indent level   False: align parameters under the open paren&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_def_param</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_def_param&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Same as indent_func_call_param, but for function defs&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_proto_param</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_proto_param&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Same as indent_func_call_param, but for function protos&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_class_param</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_class_param&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Same as indent_func_call_param, but for class declarations&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_ctor_var_param</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_ctor_var_param&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Same as indent_func_call_param, but for class variable constructors&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_template_param</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_template_param&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Same as indent_func_call_param, but for templates&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_param_double</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_param_double&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Double the indent for indent_func_xxx_param options&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_const</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_const&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Indentation column for standalone 'const' function decl/proto qualifier&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_func_throw</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_func_throw&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Indentation column for standalone 'throw' function decl/proto qualifier&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_member</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_member&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of spaces to indent a continued '-&amp;gt;' or '.'   Usually set to 0, 1, or indent_columns.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_sing_line_comments</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_sing_line_comments&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Spaces to indent single line ('//') comments on lines before code&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_relative_single_line_comments</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_relative_single_line_comments&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If set, will indent trailing single line ('//') comments relative   to the code instead of trying to keep the same absolute column&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_switch_case</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_switch_case&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Spaces to indent 'case' from 'switch'   Usually 0 or indent_columns.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_case_shift</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_case_shift&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Spaces to shift the 'case' line, without affecting any other lines   Usually 0.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_case_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_case_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Spaces to indent '{' from 'case'.   By default, the brace will appear under the 'c' in case.   Usually set to 0 or indent_columns.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_col1_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_col1_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to indent comments found in first column&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_label</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_label&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  How to indent goto labels    &amp;gt;0 : absolute column where 1 is the leftmost column    &amp;lt;=0 : subtract from brace indent&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_access_spec</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_access_spec&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Same as indent_label, but for access specifiers that are followed by a colon&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_access_spec_body</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_access_spec_body&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Indent the code after an access specifier by one level.   If set, this option forces 'indent_access_spec=0'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_paren_nl</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_paren_nl&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If an open paren is followed by a newline, indent the next line so that it lines up after the open paren (not recommended)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_paren_close</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_paren_close&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the indent of a close paren after a newline.   0: Indent to body level   1: Align under the open paren   2: Indent to the brace level&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_comma_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_comma_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the indent of a comma when inside a paren.If TRUE, aligns under the open paren&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_bool_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_bool_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the indent of a BOOL operator when inside a paren.If TRUE, aligns under the open paren&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_first_bool_expr</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_first_bool_expr&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If 'indent_bool_paren' is true, controls the indent of the first expression. If TRUE, aligns the first expression to the following ones&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_square_nl</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_square_nl&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If an open square is followed by a newline, indent the next line so that it lines up after the open square (not recommended)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_preserve_sql</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_preserve_sql&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't change the relative indent of ESQL/C 'EXEC SQL' bodies&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_align_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_align_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Align continued statements at the '='. Default=True   If FALSE or the '=' is followed by a newline, the next line is indent one tab.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_block</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_block&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Indent OC blocks at brace level instead of usual rules.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_block_msg</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_block_msg&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Indent OC blocks in a message relative to the parameter name.   0=use indent_oc_block rules, 1+=spaces to indent&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_msg_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_msg_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Minimum indent for subsequent parameters&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_msg_prioritize_first_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_msg_prioritize_first_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If true, prioritize aligning with initial colon (and stripping spaces from lines, if necessary).   Default is true.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_block_msg_xcode_style</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_block_msg_xcode_style&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If indent_oc_block_msg and this option are on, blocks will be indented the way that Xcode does by default (from keyword if the parameter is on its own line; otherwise, from the previous indentation level).&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_block_msg_from_keyword</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_block_msg_from_keyword&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If indent_oc_block_msg and this option are on, blocks will be indented from where the brace is relative to a msg keyword.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_block_msg_from_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_block_msg_from_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If indent_oc_block_msg and this option are on, blocks will be indented from where the brace is relative to a msg colon.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_block_msg_from_caret</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_block_msg_from_caret&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If indent_oc_block_msg and this option are on, blocks will be indented from where the block caret is.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>indent_oc_block_msg_from_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;indent_oc_block_msg_from_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If indent_oc_block_msg and this option are on, blocks will be indented from where the brace is.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_arith</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_arith&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around arithmetic operator '+', '-', '/', '*', etc&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around assignment operator '=', '+=', etc&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cpp_lambda_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cpp_lambda_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around '=' in C++11 lambda capture specifications. Overrides sp_assign&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cpp_lambda_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cpp_lambda_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the capture specification in C++11 lambda.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_assign_default</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_assign_default&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around assignment operator '=' in a prototype&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before assignment operator '=', '+=', etc. Overrides sp_assign.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after assignment operator '=', '+=', etc. Overrides sp_assign.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_enum_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_enum_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space in 'NS_ENUM ('&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_enum_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_enum_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around assignment '=' in enum&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_enum_before_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_enum_before_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before assignment '=' in enum. Overrides sp_enum_assign.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_enum_after_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_enum_after_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after assignment '=' in enum. Overrides sp_enum_assign.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_pp_concat</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_pp_concat&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around preprocessor '##' concatenation operator. Default=Add&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_pp_stringify</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_pp_stringify&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after preprocessor '#' stringify operator. Also affects the '#@' charizing operator.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_pp_stringify</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_pp_stringify&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before preprocessor '#' stringify operator as in '#define x(y) L#y'.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_bool</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_bool&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around boolean operators '&amp;amp;&amp;amp;' and '||'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_compare</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_compare&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around compare operator '&amp;lt;', '&amp;gt;', '==', etc&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside '(' and ')'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_paren_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_paren_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between nested parens: '((' vs ') )'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cparen_oparen</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cparen_oparen&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between back-to-back parens: ')(' vs ') ('&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_balance_nested_parens</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_balance_nested_parens&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to balance spaces inside nested parens&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_paren_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_paren_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between ')' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_ptr_star</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_ptr_star&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before pointer star '*'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_unnamed_ptr_star</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_unnamed_ptr_star&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before pointer star '*' that isn't followed by a variable name   If set to 'ignore', sp_before_ptr_star is used instead.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_between_ptr_star</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_between_ptr_star&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between pointer stars '*'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_ptr_star</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_ptr_star&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after pointer star '*', if followed by a word.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_ptr_star_qualifier</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_ptr_star_qualifier&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after pointer star '*', if followed by a qualifier.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_ptr_star_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_ptr_star_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after a pointer star '*', if followed by a func proto/def.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_ptr_star_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_ptr_star_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after a pointer star '*', if followed by an open paren (function types).&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_ptr_star_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_ptr_star_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before a pointer star '*', if followed by a func proto/def.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_byref</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_byref&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before a reference sign '&amp;amp;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_unnamed_byref</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_unnamed_byref&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before a reference sign '&amp;amp;' that isn't followed by a variable name   If set to 'ignore', sp_before_byref is used instead.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_byref</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_byref&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after reference sign '&amp;amp;', if followed by a word.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_byref_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_byref_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after a reference sign '&amp;amp;', if followed by a func proto/def.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_byref_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_byref_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before a reference sign '&amp;amp;', if followed by a func proto/def.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_type</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_type&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between type and word. Default=Force&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_template_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_template_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before the paren in the D constructs 'template Foo(' and 'class Foo('.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_template_angle</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_template_angle&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space in 'template &amp;lt;' vs 'template&amp;lt;'.   If set to ignore, sp_before_angle is used.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_angle</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_angle&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before '&amp;lt;&amp;gt;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_angle</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_angle&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside '&amp;lt;' and '&amp;gt;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_angle</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_angle&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after '&amp;lt;&amp;gt;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_angle_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_angle_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '&amp;lt;&amp;gt;' and '(' as found in 'new List&amp;lt;byte&amp;gt;();'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_angle_word</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_angle_word&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '&amp;lt;&amp;gt;' and a word as in 'List&amp;lt;byte&amp;gt; m;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_angle_shift</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_angle_shift&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '&amp;gt;' and '&amp;gt;' in '&amp;gt;&amp;gt;' (template stuff C++/C# only). Default=Add&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_permit_cpp11_shift</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_permit_cpp11_shift&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Permit removal of the space between '&amp;gt;&amp;gt;' in 'foo&amp;lt;bar&amp;lt;int&amp;gt; &amp;gt;' (C++11 only). Default=False   sp_angle_shift cannot remove the space without this option.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_sparen</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_sparen&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before '(' of 'if', 'for', 'switch', and 'while'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_sparen</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_sparen&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside if-condition '(' and ')'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_sparen_close</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_sparen_close&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before if-condition ')'. Overrides sp_inside_sparen.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_sparen_open</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_sparen_open&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before if-condition '('. Overrides sp_inside_sparen.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_sparen</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_sparen&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after ')' of 'if', 'for', 'switch', and 'while'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_sparen_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_sparen_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between ')' and '{' of 'if', 'for', 'switch', and 'while'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_invariant_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_invariant_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'invariant' and '(' in the D language.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_invariant_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_invariant_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the ')' in 'invariant (C) c' in the D language.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_special_semi</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_special_semi&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before empty statement ';' on 'if', 'for' and 'while'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_semi</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_semi&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before ';'. Default=Remove&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_semi_for</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_semi_for&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before ';' in non-empty 'for' statements&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_semi_for_empty</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_semi_for_empty&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before a semicolon of an empty part of a for statement.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_semi</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_semi&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after ';', except when followed by a comment. Default=Add&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_semi_for</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_semi_for&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after ';' in non-empty 'for' statements. Default=Force&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_semi_for_empty</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_semi_for_empty&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the final semicolon of an empty part of a for statement: for ( ; ; &amp;lt;here&amp;gt; ).&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_square</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_square&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before '[' (except '[]')&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_squares</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_squares&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before '[]'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_square</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_square&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside a non-empty '[' and ']'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_comma</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_comma&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after ','&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_comma</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_comma&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before ','&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_paren_comma</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_paren_comma&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between an open paren and comma: '(,' vs '( ,'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_ellipsis</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_ellipsis&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before the variadic '...' when preceded by a non-punctuator&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_class_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_class_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after class ':'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_class_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_class_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before class ':'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_constr_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_constr_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after class constructor ':'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_constr_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_constr_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before class constructor ':'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_case_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_case_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before case ':'. Default=Remove&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_operator</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_operator&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'operator' and operator sign&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_operator_sym</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_operator_sym&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between the operator symbol and the open paren, as in 'operator ++('&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_cast</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_cast&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after C/D cast, i.e. 'cast(int)a' vs 'cast(int) a' or '(int)a' vs '(int) a'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_paren_cast</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_paren_cast&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove spaces inside cast parens&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cpp_cast_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cpp_cast_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between the type and open paren in a C++ cast, i.e. 'int(exp)' vs 'int (exp)'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_sizeof_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_sizeof_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'sizeof' and '('&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_tag</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_tag&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the tag keyword (Pawn)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_braces_enum</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_braces_enum&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside enum '{' and '}'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_braces_struct</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_braces_struct&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside struct/union '{' and '}'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_braces</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_braces&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside '{' and '}'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_braces_empty</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_braces_empty&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside '{}'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_type_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_type_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between return type and function name   A minimum of 1 is forced except for pointer return types.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_func_proto_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_func_proto_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between function name and '(' on function declaration&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_func_def_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_func_def_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between function name and '(' on function definition&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_fparens</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_fparens&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside empty function '()'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_fparen</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_fparen&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside function '(' and ')'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_tparen</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_tparen&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside the first parens in the function type: 'void (*x)(...)'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_tparen_close</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_tparen_close&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove between the parens in the function type: 'void (*x)(...)'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_square_fparen</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_square_fparen&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between ']' and '(' when part of a function call.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_fparen_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_fparen_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between ')' and '{' of function&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_fparen_dbrace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_fparen_dbrace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Java: Add or remove space between ')' and '{{' of double brace initializer.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_func_call_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_func_call_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between function name and '(' on function calls&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_func_call_paren_empty</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_func_call_paren_empty&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between function name and '()' on function calls without parameters.   If set to 'ignore' (the default), sp_func_call_paren is used.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_func_call_user_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_func_call_user_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between the user function name and '(' on function calls   You need to set a keyword to be a user function, like this: 'set func_call_user _' in the config file.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_func_class_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_func_class_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between a constructor/destructor and the open paren&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_return_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_return_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'return' and '('&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_attribute_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_attribute_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '__attribute__' and '('&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_defined_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_defined_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'defined' and '(' in '#if defined (FOO)'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_throw_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_throw_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'throw' and '(' in 'throw (something)'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_throw</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_throw&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'throw' and anything other than '(' as in '@throw [...];'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_catch_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_catch_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'catch' and '(' in 'catch (something) { }'   If set to ignore, sp_before_sparen is used.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_version_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_version_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'version' and '(' in 'version (something) { }' (D language)   If set to ignore, sp_before_sparen is used.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_scope_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_scope_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'scope' and '(' in 'scope (something) { }' (D language)   If set to ignore, sp_before_sparen is used.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_macro</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_macro&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between macro and value&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_macro_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_macro_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between macro function ')' and value&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_else_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_else_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'else' and '{' if on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_brace_else</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_brace_else&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '}' and 'else' if on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_brace_typedef</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_brace_typedef&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '}' and the name of a typedef on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_catch_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_catch_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'catch' and '{' if on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_brace_catch</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_brace_catch&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '}' and 'catch' if on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_finally_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_finally_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'finally' and '{' if on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_brace_finally</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_brace_finally&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '}' and 'finally' if on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_try_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_try_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between 'try' and '{' if on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_getset_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_getset_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between get/set and '{' if on the same line&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_word_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_word_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between a variable and '{' for C++ uniform initialization&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_word_brace_ns</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_word_brace_ns&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between a variable and '{' for a namespace&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_dc</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_dc&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before the '::' operator&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_dc</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_dc&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the '::' operator&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_d_array_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_d_array_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove around the D named array initializer ':' operator&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_not</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_not&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the '!' (not) operator. Default=Remove&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inv</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inv&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the '~' (invert) operator. Default=Remove&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_addr</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_addr&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the '&amp;amp;' (address-of) operator. Default=Remove   This does not affect the spacing after a '&amp;amp;' that is part of a type.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_member</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_member&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around the '.' or '-&amp;gt;' operators. Default=Remove&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_deref</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_deref&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the '*' (dereference) operator. Default=Remove   This does not affect the spacing after a '*' that is part of a type.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_sign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_sign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after '+' or '-', as in 'x = -5' or 'y = +7'. Default=Remove&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_incdec</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_incdec&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before or after '++' and '--', as in '(--x)' or 'y++;'. Default=Remove&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_nl_cont</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_nl_cont&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before a backslash-newline at the end of a line. Default=Add&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_scope</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_scope&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the scope '+' or '-', as in '-(void) foo;' or '+(int) bar;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the colon in message specs   '-(int) f:(int) x;' vs '-(int) f: (int) x;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_oc_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_oc_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before the colon in message specs   '-(int) f: (int) x;' vs '-(int) f : (int) x;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_dict_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_dict_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the colon in immutable dictionary expression   'NSDictionary *test = @{@&amp;quot;foo&amp;quot; :@&amp;quot;bar&amp;quot;};'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_oc_dict_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_oc_dict_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before the colon in immutable dictionary expression   'NSDictionary *test = @{@&amp;quot;foo&amp;quot; :@&amp;quot;bar&amp;quot;};'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_send_oc_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_send_oc_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the colon in message specs   '[object setValue:1];' vs '[object setValue: 1];'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_send_oc_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_send_oc_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before the colon in message specs   '[object setValue:1];' vs '[object setValue :1];'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_type</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_type&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the (type) in message specs   '-(int)f: (int) x;' vs '-(int)f: (int)x;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_return_type</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_return_type&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the first (type) in message specs   '-(int) f:(int)x;' vs '-(int)f:(int)x;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_at_sel</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_at_sel&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '@selector' and '('   '@selector(msgName)' vs '@selector (msgName)'   Also applies to @protocol() constructs&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_at_sel_parens</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_at_sel_parens&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between '@selector(x)' and the following word   '@selector(foo) a:' vs '@selector(foo)a:'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_inside_oc_at_sel_parens</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_inside_oc_at_sel_parens&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space inside '@selector' parens   '@selector(foo)' vs '@selector( foo )'   Also applies to @protocol() constructs&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_oc_block_caret</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_oc_block_caret&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before a block pointer caret   '^int (int arg){...}' vs. ' ^int (int arg){...}'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_block_caret</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_block_caret&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after a block pointer caret   '^int (int arg){...}' vs. '^ int (int arg){...}'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_msg_receiver</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_msg_receiver&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space between the receiver and selector in a message.   '[receiver selector ...]'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_oc_property</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_oc_property&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after @property.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cond_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cond_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around the ':' in 'b ? t : f'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cond_colon_before</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cond_colon_before&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before the ':' in 'b ? t : f'. Overrides sp_cond_colon.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cond_colon_after</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cond_colon_after&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the ':' in 'b ? t : f'. Overrides sp_cond_colon.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cond_question</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cond_question&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space around the '?' in 'b ? t : f'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cond_question_before</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cond_question_before&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space before the '?' in 'b ? t : f'. Overrides sp_cond_question.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cond_question_after</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cond_question_after&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after the '?' in 'b ? t : f'. Overrides sp_cond_question.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cond_ternary_short</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cond_ternary_short&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  In the abbreviated ternary form (a ?: b), add/remove space between ? and :.'. Overrides all other sp_cond_* options.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_case_label</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_case_label&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Fix the spacing between 'case' and the label. Only 'ignore' and 'force' make sense here.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_range</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_range&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control the space around the D '..' operator.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_for_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_for_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control the spacing after ':' in 'for (TYPE VAR : EXPR)' (Java)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_for_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_for_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control the spacing before ':' in 'for (TYPE VAR : EXPR)' (Java)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_extern_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_extern_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control the spacing in 'extern (C)' (D)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_cmt_cpp_start</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_cmt_cpp_start&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control the space after the opening of a C++ comment '// A' vs '//A'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_endif_cmt</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_endif_cmt&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the spaces between #else or #endif and a trailing comment&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_after_new</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_after_new&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the spaces after 'new', 'delete', and 'delete[]'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_before_tr_emb_cmt</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_before_tr_emb_cmt&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the spaces before a trailing or embedded comment&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_num_before_tr_emb_cmt</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_num_before_tr_emb_cmt&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Number of spaces before a trailing or embedded comment&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>sp_annotation_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;sp_annotation_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control space between a Java annotation and the open paren.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_keep_tabs</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_keep_tabs&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to keep non-indenting tabs&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_with_tabs</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_with_tabs&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to use tabs for aligning&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_on_tabstop</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_on_tabstop&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to bump out to the next tab when aligning&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_number_left</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_number_left&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to left-align numbers&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_keep_extra_space</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_keep_extra_space&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to keep whitespace not required for alignment.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_func_params</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_func_params&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Align variable definitions in prototypes and functions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_same_func_call_params</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_same_func_call_params&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Align parameters in single-line functions that have the same name.   The function names must already be aligned with each other.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_def_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_def_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning variable definitions (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_def_star_style</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_def_star_style&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  How to align the star in variable definitions.    0=Part of the type     'void *   foo;'    1=Part of the variable 'void     *foo;'    2=Dangling             'void    *foo;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_def_amp_style</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_def_amp_style&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  How to align the '&amp;amp;' in variable definitions.    0=Part of the type    1=Part of the variable    2=Dangling&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_def_thresh</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_def_thresh&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The threshold for aligning variable definitions (0=no limit)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_def_gap</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_def_gap&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The gap for aligning variable definitions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_def_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_def_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to align the colon in struct bit fields&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_def_attribute</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_def_attribute&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to align any attribute after the variable name&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_def_inline</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_def_inline&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to align inline struct/enum/union variable definitions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_assign_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_assign_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning on '=' in assignments (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_assign_thresh</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_assign_thresh&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The threshold for aligning on '=' in assignments (0=no limit)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_enum_equ_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_enum_equ_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning on '=' in enums (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_enum_equ_thresh</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_enum_equ_thresh&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The threshold for aligning on '=' in enums (0=no limit)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_struct_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_struct_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning struct/union (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_struct_thresh</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_struct_thresh&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The threshold for aligning struct/union member definitions (0=no limit)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_var_struct_gap</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_var_struct_gap&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The gap for aligning struct/union member definitions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_struct_init_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_struct_init_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning struct initializer values (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_typedef_gap</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_typedef_gap&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The minimum space between the type and the synonym of a typedef&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_typedef_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_typedef_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning single-line typedefs (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_typedef_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_typedef_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  How to align typedef'd functions with other typedefs   0: Don't mix them at all   1: align the open paren with the types   2: align the function type name with the other type names&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_typedef_star_style</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_typedef_star_style&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the positioning of the '*' in typedefs. Just try it.   0: Align on typedef type, ignore '*'   1: The '*' is part of type name: typedef int  *pint;   2: The '*' is part of the type, but dangling: typedef int *pint;&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_typedef_amp_style</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_typedef_amp_style&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the positioning of the '&amp;amp;' in typedefs. Just try it.   0: Align on typedef type, ignore '&amp;amp;'   1: The '&amp;amp;' is part of type name: typedef int  &amp;amp;pint;   2: The '&amp;amp;' is part of the type, but dangling: typedef int &amp;amp;pint;&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_right_cmt_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_right_cmt_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning comments that end lines (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_right_cmt_mix</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_right_cmt_mix&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If aligning comments, mix with comments after '}' and #endif with less than 3 spaces before the comment&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_right_cmt_gap</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_right_cmt_gap&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If a trailing comment is more than this number of columns away from the text it follows,   it will qualify for being aligned. This has to be &amp;gt; 0 to do anything.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_right_cmt_at_col</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_right_cmt_at_col&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Align trailing comment at or beyond column N; 'pulls in' comments as a bonus side effect (0=ignore)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_func_proto_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_func_proto_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning function prototypes (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_func_proto_gap</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_func_proto_gap&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Minimum gap between the return type and the function name.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_on_operator</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_on_operator&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Align function protos on the 'operator' keyword instead of what follows&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_mix_var_proto</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_mix_var_proto&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to mix aligning prototype and variable declarations.   If true, align_var_def_XXX options are used instead of align_func_proto_XXX options.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_single_line_func</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_single_line_func&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Align single-line functions with function prototypes, uses align_func_proto_span&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_single_line_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_single_line_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Aligning the open brace of single-line functions.   Requires align_single_line_func=true, uses align_func_proto_span&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_single_line_brace_gap</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_single_line_brace_gap&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Gap for align_single_line_brace.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_oc_msg_spec_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_oc_msg_spec_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning ObjC msg spec (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_nl_cont</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_nl_cont&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to align macros wrapped with a backslash and a newline.   This will not work right if the macro contains a multi-line comment.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_pp_define_together</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_pp_define_together&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  # Align macro functions and variables together&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_pp_define_gap</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_pp_define_gap&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The minimum space between label and value of a preprocessor define&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_pp_define_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_pp_define_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The span for aligning on '#define' bodies (0=don't align, other=number of lines including comments between blocks)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_left_shift</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_left_shift&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Align lines that start with '&amp;lt;&amp;lt;' with previous '&amp;lt;&amp;lt;'. Default=true&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_oc_msg_colon_span</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_oc_msg_colon_span&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Span for aligning parameters in an Obj-C message call on the ':' (0=don't align)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_oc_msg_colon_first</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_oc_msg_colon_first&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If true, always align with the first parameter, even if it is too short.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>align_oc_decl_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;align_oc_decl_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Aligning parameters in an Obj-C '+' or '-' declaration on the ':'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_collapse_empty_body</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_collapse_empty_body&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to collapse empty blocks between '{' and '}'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_assign_leave_one_liners</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_assign_leave_one_liners&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't split one-line braced assignments - 'foo_t f = { 1, 2 };'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_class_leave_one_liners</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_class_leave_one_liners&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't split one-line braced statements inside a class xx { } body&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_enum_leave_one_liners</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_enum_leave_one_liners&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't split one-line enums: 'enum foo { BAR = 15 };'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_getset_leave_one_liners</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_getset_leave_one_liners&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't split one-line get or set functions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_leave_one_liners</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_leave_one_liners&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't split one-line function definitions - 'int foo() { return 0; }'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_cpp_lambda_leave_one_liners</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_cpp_lambda_leave_one_liners&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't split one-line C++11 lambdas - '[]() { return 0; }'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_if_leave_one_liners</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_if_leave_one_liners&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't split one-line if/else statements - 'if(a) b++;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_oc_msg_leave_one_liner</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_oc_msg_leave_one_liner&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't split one-line OC messages&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_start_of_file</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_start_of_file&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newlines at the start of the file&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_start_of_file_min</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_start_of_file_min&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines at the start of the file (only used if nl_start_of_file is 'add' or 'force'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_end_of_file</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_end_of_file&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline at the end of the file&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_end_of_file_min</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_end_of_file_min&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines at the end of the file (only used if nl_end_of_file is 'add' or 'force')&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_assign_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_assign_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '=' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_assign_square</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_assign_square&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '=' and '[' (D only)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_square_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_square_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline after '= [' (D only). Will also affect the newline before the ']'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_var_def_blk</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_var_def_blk&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of blank lines after a block of variable definitions at the top of a function body   0 = No change (default)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_typedef_blk_start</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_typedef_blk_start&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines before a block of typedefs   0 = No change (default)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_typedef_blk_end</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_typedef_blk_end&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after a block of typedefs   0 = No change (default)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_typedef_blk_in</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_typedef_blk_in&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The maximum consecutive newlines within a block of typedefs   0 = No change (default)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_var_def_blk_start</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_var_def_blk_start&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines before a block of variable definitions not at the top of a function body   0 = No change (default)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_var_def_blk_end</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_var_def_blk_end&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after a block of variable definitions not at the top of a function body   0 = No change (default)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_var_def_blk_in</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_var_def_blk_in&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The maximum consecutive newlines within a block of variable definitions   0 = No change (default)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_fcall_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_fcall_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between a function call's ')' and '{', as in:   list_for_each(item, &amp;amp;list) { }&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_enum_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_enum_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'enum' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_struct_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_struct_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'struct and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_union_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_union_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'union' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_if_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_if_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'if' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_brace_else</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_brace_else&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '}' and 'else'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_elseif_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_elseif_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'else if' and '{'   If set to ignore, nl_if_brace is used instead&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_else_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_else_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'else' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_else_if</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_else_if&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'else' and 'if'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_brace_finally</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_brace_finally&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '}' and 'finally'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_finally_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_finally_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'finally' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_try_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_try_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'try' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_getset_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_getset_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between get/set and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_for_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_for_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'for' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_catch_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_catch_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'catch' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_brace_catch</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_brace_catch&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '}' and 'catch'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_brace_square</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_brace_square&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '}' and ']'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_brace_fparen</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_brace_fparen&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '}' and ')' in a function invocation&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_while_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_while_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'while' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_scope_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_scope_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'scope (x)' and '{' (D)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_unittest_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_unittest_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'unittest' and '{' (D)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_version_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_version_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'version (x)' and '{' (D)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_using_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_using_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'using' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_brace_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_brace_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between two open or close braces.   Due to general newline/brace handling, REMOVE may not work.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_do_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_do_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'do' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_brace_while</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_brace_while&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '}' and 'while' of 'do' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_switch_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_switch_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'switch' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_multi_line_cond</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_multi_line_cond&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add a newline between ')' and '{' if the ')' is on a different line than the if/for/etc.   Overrides nl_for_brace, nl_if_brace, nl_switch_brace, nl_while_switch, and nl_catch_brace.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_multi_line_define</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_multi_line_define&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Force a newline in a define after the macro name for multi-line defines.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_case</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_case&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline before 'case' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_throw</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_throw&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between ')' and 'throw'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_case</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_case&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline after 'case' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_case_colon_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_case_colon_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove a newline between a case ':' and '{'. Overrides nl_after_case.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_namespace_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_namespace_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Newline between namespace and {&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_template_class</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_template_class&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'template&amp;lt;&amp;gt;' and whatever follows.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_class_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_class_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between 'class' and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_class_init_args</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_class_init_args&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline after each ',' in the class base list&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_constr_init_args</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_constr_init_args&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline after each ',' in the constructor member initialization&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_type_name</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_type_name&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between return type and function name in a function definition&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_type_name_class</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_type_name_class&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between return type and function name inside a class {}   Uses nl_func_type_name or nl_func_proto_type_name if set to ignore.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_scope_name</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_scope_name&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between function scope and name in a definition   Controls the newline after '::' in 'void A::f() { }'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_proto_type_name</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_proto_type_name&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between return type and function name in a prototype&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between a function name and the opening '('&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_def_paren</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_def_paren&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between a function name and the opening '(' in the definition&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_decl_start</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_decl_start&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline after '(' in a function declaration&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_def_start</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_def_start&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline after '(' in a function definition&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_decl_start_single</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_decl_start_single&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Overrides nl_func_decl_start when there is only one parameter.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_def_start_single</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_def_start_single&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Overrides nl_func_def_start when there is only one parameter.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_decl_args</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_decl_args&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline after each ',' in a function declaration&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_def_args</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_def_args&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline after each ',' in a function definition&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_decl_end</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_decl_end&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline before the ')' in a function declaration&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_def_end</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_def_end&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline before the ')' in a function definition&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_decl_end_single</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_decl_end_single&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Overrides nl_func_decl_end when there is only one parameter.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_def_end_single</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_def_end_single&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Overrides nl_func_def_end when there is only one parameter.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_decl_empty</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_decl_empty&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '()' in a function declaration.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_func_def_empty</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_func_def_empty&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between '()' in a function definition.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_oc_msg_args</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_oc_msg_args&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put each OC message parameter on a separate line   See nl_oc_msg_leave_one_liner&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_fdef_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_fdef_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between function signature and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_cpp_ldef_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_cpp_ldef_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between C++11 lambda signature and '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_return_expr</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_return_expr&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove a newline between the return keyword and return expression.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_semicolon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_semicolon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline after semicolons, except in 'for' statements&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_paren_dbrace_open</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_paren_dbrace_open&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Java: Control the newline between the ')' and '{{' of the double brace initializer.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_brace_open</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_brace_open&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline after brace open.   This also adds a newline before the matching brace close.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_brace_open_cmt</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_brace_open_cmt&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If nl_after_brace_open and nl_after_brace_open_cmt are true, a newline is   placed between the open brace and a trailing single-line comment.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_vbrace_open</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_vbrace_open&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline after a virtual brace open with a non-empty body.   These occur in un-braced if/while/do/for statement bodies.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_vbrace_open_empty</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_vbrace_open_empty&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline after a virtual brace open with an empty body.   These occur in un-braced if/while/do/for statement bodies.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_brace_close</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_brace_close&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline after a brace close.   Does not apply if followed by a necessary ';'.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_vbrace_close</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_vbrace_close&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline after a virtual brace close.   Would add a newline before return in: 'if (foo) a++; return;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_brace_struct_var</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_brace_struct_var&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control the newline between the close brace and 'b' in: 'struct { int a; } b;'   Affects enums, unions, and structures. If set to ignore, uses nl_after_brace_close&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_define_macro</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_define_macro&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to alter newlines in '#define' macros&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_squeeze_ifdef</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_squeeze_ifdef&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to not put blanks after '#ifxx', '#elxx', or before '#endif'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_if</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_if&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line before 'if'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_if</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_if&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line after 'if' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_for</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_for&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line before 'for'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_for</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_for&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line after 'for' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_while</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_while&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line before 'while'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_while</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_while&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line after 'while' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_switch</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_switch&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line before 'switch'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_switch</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_switch&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line after 'switch' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_do</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_do&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line before 'do'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_do</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_do&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove blank line after 'do/while' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_ds_struct_enum_cmt</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_ds_struct_enum_cmt&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to double-space commented-entries in struct/enum&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_ds_struct_enum_close_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_ds_struct_enum_close_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to double-space before the close brace of a struct/union/enum   (lower priority than 'eat_blanks_before_close_brace')&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_class_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_class_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove a newline around a class colon.   Related to pos_class_colon, nl_class_init_args, and pos_class_comma.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_constr_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_constr_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove a newline around a class constructor colon.   Related to pos_constr_colon, nl_constr_init_args, and pos_constr_comma.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_create_if_one_liner</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_create_if_one_liner&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Change simple unbraced if statements into a one-liner   'if(b)\n i++;' =&amp;gt; 'if(b) i++;'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_create_for_one_liner</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_create_for_one_liner&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Change simple unbraced for statements into a one-liner   'for (i=0;i&amp;lt;5;i++)\n foo(i);' =&amp;gt; 'for (i=0;i&amp;lt;5;i++) foo(i);'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_create_while_one_liner</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_create_while_one_liner&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Change simple unbraced while statements into a one-liner   'while (i&amp;lt;5)\n foo(i++);' =&amp;gt; 'while (i&amp;lt;5) foo(i++);'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_arith</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_arith&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of arithmetic operators in wrapped expressions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_assign</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_assign&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of assignment in wrapped expressions.   Do not affect '=' followed by '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_bool</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_bool&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of boolean operators in wrapped expressions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_compare</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_compare&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of comparison operators in wrapped expressions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_conditional</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_conditional&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of conditional (b ? t : f) operators in wrapped expressions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_comma</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_comma&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of the comma in wrapped expressions&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_class_comma</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_class_comma&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of the comma in the class base list&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_constr_comma</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_constr_comma&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of the comma in the constructor initialization list&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_class_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_class_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of colons between class and base class list&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pos_constr_colon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pos_constr_colon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Lead, Trail }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The position of colons between constructor and member initialization&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>code_width</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;code_width&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Try to limit code width to N number of columns&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>ls_for_split_full</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;ls_for_split_full&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to fully split long 'for' statements at semi-colons&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>ls_func_split_full</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;ls_func_split_full&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to fully split long function protos/calls at commas&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>ls_code_width</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;ls_code_width&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to split lines as close to code_width as possible and ignore some groupings&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_max</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_max&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The maximum consecutive newlines&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_func_proto</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_func_proto&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after a function prototype, if followed by another function prototype&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_func_proto_group</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_func_proto_group&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after a function prototype, if not followed by another function prototype&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_func_body</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_func_body&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after '}' of a multi-line function body&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_func_body_class</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_func_body_class&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after '}' of a multi-line function body in a class declaration&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_func_body_one_liner</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_func_body_one_liner&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after '}' of a single line function body&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_block_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_block_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The minimum number of newlines before a multi-line comment.   Doesn't apply if after a brace open or another multi-line comment.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_c_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_c_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The minimum number of newlines before a single-line C comment.   Doesn't apply if after a brace open or other single-line C comments.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_cpp_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_cpp_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The minimum number of newlines before a CPP comment.   Doesn't apply if after a brace open or other CPP comments.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_multiline_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_multiline_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to force a newline after a multi-line comment.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_struct</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_struct&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after '}' or ';' of a struct/enum/union definition&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_class</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_class&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after '}' or ';' of a class definition&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_access_spec</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_access_spec&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines before a 'private:', 'public:', 'protected:', 'signals:', or 'slots:' label.   Will not change the newline count if after a brace open.   0 = No change.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_access_spec</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_access_spec&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after a 'private:', 'public:', 'protected:', 'signals:', or 'slots:' label.   0 = No change.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_comment_func_def</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_comment_func_def&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines between a function def and the function comment.   0 = No change.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_try_catch_finally</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_try_catch_finally&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines after a try-catch-finally block that isn't followed by a brace close.   0 = No change.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_around_cs_property</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_around_cs_property&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines before and after a property, indexer or event decl.   0 = No change.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_between_get_set</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_between_get_set&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of newlines between the get/set/add/remove handlers in C#.   0 = No change.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_property_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_property_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove newline between C# property and the '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>eat_blanks_after_open_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;eat_blanks_after_open_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to remove blank lines after '{'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>eat_blanks_before_close_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;eat_blanks_before_close_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to remove blank lines before '}'&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_remove_extra_newlines</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_remove_extra_newlines&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  How aggressively to remove extra newlines not in preproc.   0: No change   1: Remove most newlines not handled by other config   2: Remove all newlines and reformat completely by config&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_before_return</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_before_return&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a blank line before 'return' statements, unless after an open brace.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_return</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_return&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a blank line after 'return' statements, unless followed by a close brace.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_after_annotation</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_after_annotation&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline after a Java annotation statement.   Only affects annotations that are after a newline.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>nl_between_annotation</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;nl_between_annotation&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Controls the newline between two annotations.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_brace_do</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_brace_do&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove braces on single-line 'do' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_brace_for</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_brace_for&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove braces on single-line 'for' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_brace_function</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_brace_function&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove braces on single-line function definitions. (Pawn)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_brace_if</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_brace_if&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove braces on single-line 'if' statement. Will not remove the braces if they contain an 'else'.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_brace_if_chain</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_brace_if_chain&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Make all if/elseif/else statements in a chain be braced or not. Overrides mod_full_brace_if.   If any must be braced, they are all braced.  If all can be unbraced, then the braces are removed.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_brace_nl</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_brace_nl&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Don't remove braces around statements that span N newlines&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_brace_while</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_brace_while&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove braces on single-line 'while' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_brace_using</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_brace_using&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove braces on single-line 'using ()' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_paren_on_return</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_paren_on_return&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove unnecessary paren on 'return' statement&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_pawn_semicolon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_pawn_semicolon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to change optional semicolons to real semicolons&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_full_paren_if_bool</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_full_paren_if_bool&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add parens on 'while' and 'if' statement around bools&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_remove_extra_semicolon</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_remove_extra_semicolon&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to remove superfluous semicolons&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_add_long_function_closebrace_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_add_long_function_closebrace_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If a function body exceeds the specified number of newlines and doesn't have a comment after   the close brace, a comment will be added.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_add_long_namespace_closebrace_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_add_long_namespace_closebrace_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If a namespace body exceeds the specified number of newlines and doesn't have a comment after   the close brace, a comment will be added.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_add_long_switch_closebrace_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_add_long_switch_closebrace_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If a switch body exceeds the specified number of newlines and doesn't have a comment after   the close brace, a comment will be added.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_add_long_ifdef_endif_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_add_long_ifdef_endif_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If an #ifdef body exceeds the specified number of newlines and doesn't have a comment after   the #endif, a comment will be added.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_add_long_ifdef_else_comment</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_add_long_ifdef_else_comment&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If an #ifdef or #else body exceeds the specified number of newlines and doesn't have a comment after   the #else, a comment will be added.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_sort_import</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_sort_import&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If TRUE, will sort consecutive single-line 'import' statements [Java, D]&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_sort_using</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_sort_using&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If TRUE, will sort consecutive single-line 'using' statements [C#]&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_sort_include</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_sort_include&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If TRUE, will sort consecutive single-line '#include' statements [C/C++] and '#import' statements [Obj-C]   This is generally a bad idea, as it may break your code.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_move_case_break</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_move_case_break&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If TRUE, it will move a 'break' that appears after a fully braced 'case' before the close brace.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_case_brace</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_case_brace&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Will add or remove the braces around a fully braced case statement.   Will only remove the braces if there are no variable declarations in the block.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>mod_remove_empty_return</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;mod_remove_empty_return&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If TRUE, it will remove a void 'return;' that appears as the last statement in a function.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_width</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_width&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Try to wrap comments at cmt_width columns&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_reflow_mode</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_reflow_mode&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Set the comment reflow mode (default: 0)   0: no reflowing (apart from the line wrapping due to cmt_width)   1: no touching at all   2: full reflow&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_convert_tab_to_spaces</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_convert_tab_to_spaces&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to convert all tabs to spaces in comments. Default is to leave tabs inside comments alone, unless used for indenting.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_indent_multi</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_indent_multi&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If false, disable all multi-line comment changes, including cmt_width. keyword substitution, and leading chars.   Default is true.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_c_group</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_c_group&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to group c-comments that look like they are in a block&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_c_nl_start</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_c_nl_start&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put an empty '/*' on the first line of the combined c-comment&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_c_nl_end</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_c_nl_end&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline before the closing '*/' of the combined c-comment&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_cpp_group</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_cpp_group&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to group cpp-comments that look like they are in a block&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_cpp_nl_start</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_cpp_nl_start&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put an empty '/*' on the first line of the combined cpp-comment&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_cpp_nl_end</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_cpp_nl_end&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a newline before the closing '*/' of the combined cpp-comment&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_cpp_to_c</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_cpp_to_c&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to change cpp-comments into c-comments&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_star_cont</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_star_cont&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to put a star on subsequent comment lines&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_sp_before_star_cont</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_sp_before_star_cont&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of spaces to insert at the start of subsequent comment lines&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_sp_after_star_cont</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_sp_after_star_cont&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The number of spaces to insert after the star on subsequent comment lines&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_multi_check_last</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_multi_check_last&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  For multi-line comments with a '*' lead, remove leading spaces if the first and last lines of   the comment are the same length. Default=True&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_insert_file_header</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_insert_file_header&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;String&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The filename that contains text to insert at the head of a file if the file doesn't start with a C/C++ comment.   Will substitute $(filename) with the current file's name.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_insert_file_footer</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_insert_file_footer&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;String&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The filename that contains text to insert at the end of a file if the file doesn't end with a C/C++ comment.   Will substitute $(filename) with the current file's name.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_insert_func_header</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_insert_func_header&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;String&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The filename that contains text to insert before a function implementation if the function isn't preceded with a C/C++ comment.   Will substitute $(function) with the function name and $(javaparam) with the javadoc @param and @return stuff.   Will also substitute $(fclass) with the class name: void CFoo::Bar() { ... }&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_insert_class_header</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_insert_class_header&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;String&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The filename that contains text to insert before a class if the class isn't preceded with a C/C++ comment.   Will substitute $(class) with the class name.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_insert_oc_msg_header</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_insert_oc_msg_header&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;String&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The filename that contains text to insert before a Obj-C message specification if the method isn't preceded with a C/C++ comment.   Will substitute $(message) with the function name and $(javaparam) with the javadoc @param and @return stuff.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>cmt_insert_before_preproc</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;cmt_insert_before_preproc&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If a preprocessor is encountered when stepping backwards from a function name, then   this option decides whether the comment should be inserted.   Affects cmt_insert_oc_msg_header, cmt_insert_func_header and cmt_insert_class_header.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_indent</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_indent&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control indent of preprocessors inside #if blocks at brace level 0 (file-level)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_indent_at_level</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_indent_at_level&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to indent #if/#else/#endif at the brace level (true) or from column 1 (false)&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_indent_count</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_indent_count&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Specifies the number of columns to indent preprocessors per level at brace level 0 (file-level).   If pp_indent_at_level=false, specifies the number of columns to indent preprocessors per level at brace level &amp;gt; 0 (function-level).   Default=1.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_space</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_space&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ Ignore, Add, Remove, Force }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Add or remove space after # based on pp_level of #if blocks&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_space_count</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_space_count&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Sets the number of spaces added with pp_space&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_indent_region</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_indent_region&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  The indent for #region and #endregion in C# and '#pragma region' in C/C++&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_region_indent_code</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_region_indent_code&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to indent the code between #region and #endregion&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_indent_if</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_indent_if&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;Number&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  If pp_indent_at_level=true, sets the indent for #if, #else, and #endif when not at file-level.   0:  indent preprocessors using output_tab_size.   &amp;gt;0: column at which all preprocessors will be indented.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_if_indent_code</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_if_indent_code&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Control whether to indent the code between #if, #else and #endif.&lt;/p&gt;</doc>
    </entry>
    <entry>
        <key>pp_define_at_level</key>
        <doc>&lt;p&gt;&lt;span class=&quot;option&quot;&gt;pp_define_at_level&lt;/span&gt; &lt;span class=&quot;param&quot;&gt;{ False, True }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  Whether to indent '#define' at the brace level (true) or from column 1 (false)&lt;/p&gt;</doc>
    </entry>
</beautifier_documentation>
